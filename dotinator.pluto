local { json } = require "*"

local dict_en <const> = io.contents("dicts/en.json") |> json.decode

local nodes

local function emit_dot(filename, start)
	local pending_nodes = { start }
	local emitted_nodes = {}

	local fh <close> = io.open(filename, "w")
	fh:write("digraph {\n")
	local function get_node_name(node)
		if node.type == "/EE/Types/Engine/EndDialogueNode" then
			if node.name then
				return '"Chat ends. Next chat will be '..node.name..'."'
			else
				return '"Chat ends."'
			end
		elseif node.type == "/EE/Types/Engine/SpecialCompletionDialogueNode" and #node.refs == 0 then
			assert(#node.choices == 1)
			assert(nodes[1 + node.choices[1]].type == "/EE/Types/Engine/EndDialogueNode")
			assert(nodes[1 + node.choices[1]].name == nil)
			return '"Chat ends."'
		elseif node.type == "/EE/Types/Engine/StartDialogueNode" then
			return '"'..node.name..' begins."'
		elseif node.type == "/EE/Types/Engine/SetBooleanDialogueNode" or node.type == "/EE/Types/Engine/ResetBooleanDialogueNode" then
			local str = '"'..node.type..':'..node.name
			for node.choices as choice do
				str ..= ':'
				str ..= get_node_name(nodes[1 + choice]):replace('"', '')
			end
			return str..'"'
		else
			return tostring(node.id)
		end
	end
	local function write_node_name(node)
		fh:write(get_node_name(node))
	end
	local function write_node_label(node)
		switch node.type do
			case "/EE/Types/Engine/ChemistryDialogueNode":
				fh:write('"+')
				fh:write(node.chemistry)
				fh:write(' Chemistry"')
				break
			case "/EE/Types/Engine/SetBooleanDialogueNode":
				fh:write('"Boolean ')
				fh:write(node.name)
				fh:write(' is now true."')
				break
			case "/EE/Types/Engine/ResetBooleanDialogueNode":
				fh:write('"Boolean ')
				fh:write(node.name)
				fh:write(' is now false."')
				break
			case "/EE/Types/Engine/CheckBooleanDialogueNode":
				fh:write('"Check boolean ')
				fh:write(node.name)
				fh:write('"')
				break
			case "/EE/Types/Engine/CheckBooleanScriptDialogueNode":
				fh:write('"Check ')
				fh:write(node.script_name)
				fh:write(" for boolean ")
				fh:write(node.arg1)
				fh:write('"')
				break
			case "/EE/Types/Engine/DialogueNode":
			case "/EE/Types/Engine/PlayerChoiceDialogueNode":
				fh:write('"')
				if node.nickname_override then
					fh:write(dict_en[node.nickname_override] or node.nickname_override)
					fh:write(": ")
				end
				do
					local text = (dict_en[node.name] or node.name)
					if node.vars then
						for k, v in node.vars do
							text = text:replace("|"..k.."|", dict_en[v] or v)
						end
					end
					fh:write(text:replace('"', '\\"'))
				end
				fh:write('"')
				break
			case "/EE/Types/Engine/ScriptDialogueNode":
				fh:write('"Invoke ')
				fh:write(node.script_name)
				fh:write('"')
				break
			default:
				fh:write('"')
				fh:write(node.type)
				fh:write('"')
				break
		end
	end
	while #pending_nodes ~= 0 do
		local node_id = pending_nodes:remove()
		local node = nodes[1 + node_id]
		local node_name = get_node_name(node)

		if emitted_nodes[node_name] then
			continue
		end
		emitted_nodes[node_name] = true

		fh:write("\t")
		switch node.type do
			case "/EE/Types/Engine/DialogueNode":
				fh:write(node.id)
				fh:write(" [label=")
				write_node_label(node)
				fh:write(",shape=box,color=blue];\n")
				break
			case "/EE/Types/Engine/PlayerChoiceDialogueNode":
				fh:write(node.id)
				fh:write(" [label=")
				write_node_label(node)
				fh:write(",shape=box,color=red];\n")
				break
			case "/EE/Types/Engine/StartDialogueNode":
			case "/EE/Types/Engine/EndDialogueNode":
				fh:write(node_name)
				fh:write(" [color=orange];\n")
				break
			case "/EE/Types/Engine/SpecialCompletionDialogueNode":
				fh:write(node_name)
				if #node.refs == 0 then
					fh:write(" [color=orange];\n")
					continue -- Don't write transition to EndDialogueNode
				end
				fh:write(" [label=")
				fh:write('"Initiate conversation '..node.refs[1].convo..' in '..node.refs[1].diag..'"')
				fh:write(",color=orange];\n")
				break
			default:
				fh:write(node_name)
				fh:write(" [label=")
				write_node_label(node)
				fh:write(",color=orange];\n")
				break
		end

		if node.true_choices then
			for node.true_choices as choice do
				fh:write("\t\t")
				fh:write(node_name)
				fh:write(" -> ")
				write_node_name(nodes[1 + choice])
				fh:write(" [label=true,color=green];\n")
				pending_nodes:insert(1, choice)
			end
			for node.false_choices as choice do
				fh:write("\t\t")
				fh:write(node_name)
				fh:write(" -> ")
				write_node_name(nodes[1 + choice])
				fh:write(" [label=false,color=brown];\n")
				pending_nodes:insert(1, choice)
			end
		else
			for node.choices as choice do
				fh:write("\t\t")
				fh:write(node_name)
				fh:write(" -> ")
				write_node_name(nodes[1 + choice])
				fh:write(";\n")
				pending_nodes:insert(1, choice)
			end
		end
	end
	fh:write("}")
end

for {
	"AoiDialogue_rom.dialogue",
	"ArthurDialogue_rom.dialogue",
	"EleanorDialogue_rom.dialogue",
	"HexDialogue_rom.dialogue",
	"JabirDialogue_rom.dialogue",
	"LettieDialogue_rom.dialogue",
	"QuincyDialogue_rom.dialogue",
} as diag_name do
	nodes = io.contents(diag_name..".json") |> json.decode

	io.makedir("flowcharts")
	io.makedir("flowcharts/"..diag_name)
	io.makedir("flowcharts_dot")
	io.makedir("flowcharts_dot/"..diag_name)

	print(diag_name)
	for nodes as node do
		if node.type == "/EE/Types/Engine/StartDialogueNode" then
			print("\t"..node.name)
			local prev_dot = io.contents("flowcharts_dot/"..diag_name.."/"..node.name..".dot")
			emit_dot("flowcharts_dot/"..diag_name.."/"..node.name..".dot", node.id)
			if prev_dot ~= io.contents("flowcharts_dot/"..diag_name.."/"..node.name..".dot") then
				os.execute("dot flowcharts_dot/"..diag_name.."/"..node.name..".dot -T png -o flowcharts/"..diag_name.."/"..node.name..".png")
			end
		end
	end
end
