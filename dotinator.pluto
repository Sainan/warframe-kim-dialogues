local { json } = require "*"

local dict_en <const> = io.contents("dicts/en.json") |> json.decode

local nodes

local function get_node_label(node)
	switch node.type do
		case "/EE/Types/Engine/ChemistryDialogueNode":
			return $"+{node.chemistry} Chemistry"
		case "/EE/Types/Engine/SetBooleanDialogueNode":
			return $"Boolean {node.name} is now true."
		case "/EE/Types/Engine/ResetBooleanDialogueNode":
			return $"Boolean {node.name} is now false."
		case "/EE/Types/Engine/CheckBooleanDialogueNode":
			return $"Check boolean {node.name}"
		case "/EE/Types/Engine/CheckBooleanScriptDialogueNode":
			return $"Check {node.script_name} for boolean {node.arg1}"
		case "/EE/Types/Engine/DialogueNode":
		case "/EE/Types/Engine/PlayerChoiceDialogueNode":
			do
				local text = (dict_en[node.name] or node.name)
				if node.vars then
					for k, v in node.vars do
						text = text:replace("|"..k.."|", dict_en[v] or v)
					end
				end
				if node.nickname_override then
					text = (dict_en[node.nickname_override] or node.nickname_override)..": "..text
				end
				return text
			end
			break
		case "/EE/Types/Engine/ScriptDialogueNode":
			return $"Invoke {node.script_name}"
		default:
			return node.type
	end
end

local function get_node_name(node)
	if node.type == "/EE/Types/Engine/EndDialogueNode" then
		if node.name then
			return '"Chat ends. Next chat will be '..node.name..'."'
		else
			return '"Chat ends."'
		end
	elseif node.type == "/EE/Types/Engine/SpecialCompletionDialogueNode" and #node.refs == 0 then
		assert(#node.choices == 1)
		assert(nodes[1 + node.choices[1]].type == "/EE/Types/Engine/EndDialogueNode")
		assert(nodes[1 + node.choices[1]].name == nil)
		return '"Chat ends."'
	elseif node.type == "/EE/Types/Engine/StartDialogueNode" then
		return '"'..node.name..' begins."'
	elseif node.type == "/EE/Types/Engine/SetBooleanDialogueNode" or node.type == "/EE/Types/Engine/ResetBooleanDialogueNode" then
		local str = '"'..node.type..':'..node.name
		for node.choices as choice do
			str ..= ':'
			str ..= get_node_name(nodes[1 + choice]):replace('"', '')
		end
		return str..'"'
	else
		return tostring(node.id)
	end
end

local function emit_dot(filename, start)
	local pending_nodes = { start }
	local emitted_nodes = {}

	local fh <close> = io.open(filename, "w")
	fh:write("digraph {\n")
	local function write_node_name(node)
		fh:write(get_node_name(node))
	end
	local function write_node_label(node)
		fh:write('"')
		fh:write(get_node_label(node):replace('"', '\\"'))
		fh:write('"')
	end
	while #pending_nodes ~= 0 do
		local node_id = pending_nodes:remove()
		local node = nodes[1 + node_id]
		local node_name = get_node_name(node)

		if emitted_nodes[node_name] then
			continue
		end
		emitted_nodes[node_name] = true

		fh:write("\t")
		switch node.type do
			case "/EE/Types/Engine/DialogueNode":
				fh:write(node.id)
				fh:write(" [label=")
				write_node_label(node)
				fh:write(",shape=box,color=blue];\n")
				break
			case "/EE/Types/Engine/PlayerChoiceDialogueNode":
				fh:write(node.id)
				fh:write(" [label=")
				write_node_label(node)
				fh:write(",shape=box,color=red];\n")
				break
			case "/EE/Types/Engine/StartDialogueNode":
			case "/EE/Types/Engine/EndDialogueNode":
				fh:write(node_name)
				fh:write(" [color=orange];\n")
				break
			case "/EE/Types/Engine/SpecialCompletionDialogueNode":
				fh:write(node_name)
				if #node.refs == 0 then
					fh:write(" [color=orange];\n")
					continue -- Don't write transition to EndDialogueNode
				end
				fh:write(" [label=")
				fh:write('"Initiate conversation '..node.refs[1].convo..' in '..node.refs[1].diag..'"')
				fh:write(",color=orange];\n")
				break
			default:
				fh:write(node_name)
				fh:write(" [label=")
				write_node_label(node)
				fh:write(",color=orange];\n")
				break
		end

		if node.true_choices then
			for node.true_choices as choice do
				fh:write("\t\t")
				fh:write(node_name)
				fh:write(" -> ")
				write_node_name(nodes[1 + choice])
				fh:write(" [label=true,color=green];\n")
				pending_nodes:insert(1, choice)
			end
			for node.false_choices as choice do
				fh:write("\t\t")
				fh:write(node_name)
				fh:write(" -> ")
				write_node_name(nodes[1 + choice])
				fh:write(" [label=false,color=brown];\n")
				pending_nodes:insert(1, choice)
			end
		else
			for node.choices as choice do
				fh:write("\t\t")
				fh:write(node_name)
				fh:write(" -> ")
				write_node_name(nodes[1 + choice])
				fh:write(";\n")
				pending_nodes:insert(1, choice)
			end
		end
	end
	fh:write("}")
end

for {
	"AoiDialogue_rom.dialogue",
	"ArthurDialogue_rom.dialogue",
	"EleanorDialogue_rom.dialogue",
	"HexDialogue_rom.dialogue",
	"JabirDialogue_rom.dialogue",
	"LettieDialogue_rom.dialogue",
	"QuincyDialogue_rom.dialogue",
} as diag_name do
	nodes = io.contents(diag_name..".json") |> json.decode

	io.makedir("flowcharts")
	io.makedir("flowcharts/"..diag_name)
	io.makedir("flowcharts_dot")
	io.makedir("flowcharts_dot/"..diag_name)

	print(diag_name)
	for nodes as node do
		if node.type == "/EE/Types/Engine/StartDialogueNode" then
			print("\t"..node.name)
			local prev_dot = io.contents("flowcharts_dot/"..diag_name.."/"..node.name..".dot")
			emit_dot("flowcharts_dot/"..diag_name.."/"..node.name..".dot", node.id)
			if prev_dot ~= io.contents("flowcharts_dot/"..diag_name.."/"..node.name..".dot") then
				os.execute("dot flowcharts_dot/"..diag_name.."/"..node.name..".dot -T png -o flowcharts/"..diag_name.."/"..node.name..".png")
			end
		end
	end
end
